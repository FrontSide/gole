package main

import (
    "log"
    "unicode/utf8"
    "os/exec"
    "reflect"
    "strings"
    "errors"
    "./golelibs"
);

type Game struct {
    Id string;
    Players []Player;

    // hold index of player who has the current turn
    PlayerIdxWithTurn int;

    // 2-dimensional array storing all tiles
    // first index represents vertical, second index horizontal tiles
    Tiles [][]Tile;

    // String of all letters in the backlog
    // i.e. that have not yet been handed to a player
    LetterSet string;
}

var MIN_NUMBER_OF_PLAYERS = 2
var MAX_NUMBER_OF_PLAYERS = 4
var DEFAULT_NUMBER_OF_LETTERS_IN_HAND = 7

func GetNewUUID() string {
    // Generate a new uuid for a new game.
    // Requires:
    // - The existance of a uuidgen binary installed on the machine
    // Guarantees
    // - Return a new uuid as generated by the called binary
    uuid, err := exec.Command("uuidgen").Output()
    if err != nil {
        log.Fatal(err)
    }
    return strings.TrimSpace(string(uuid))
}

func (game *Game) GetPlayerByName(playerName string) (Player, error) {
    // get a player from the given game by their name
    for _, existingPlayer := range game.Players {
        if existingPlayer.Name == strings.TrimSpace(playerName) {
            return existingPlayer, nil
        }
    }
    return Player{}, errors.New("Player with name does not exist in the game. " + playerName)
}

func AddPlayer(playerName string, game *Game) error {
    // Add a player to the list of players for the
    // upcoming game play

    if len(game.Players) >= MAX_NUMBER_OF_PLAYERS {
        log.Fatal("No more players can be added to the Game.")
    }

    _, err := game.GetPlayerByName(playerName)
    if err == nil {
        errors.New("A player with this name already exists.")
    }

    player := Player{Name: playerName}

    for i := 0; i < DEFAULT_NUMBER_OF_LETTERS_IN_HAND; i++ {
        player.LettersInHand += PopLetterFromSet(game)
    }

    game.Players = append(game.Players, player)

    return nil

}

func PopLetterFromSet(game *Game) string {
    // Pop the last letter (right end) from the
    // letter string of the passed game structure instance.
    // The letter will be returned and the
    // occurrence will be removed from the string and stored back to the game.
    if len(game.LetterSet) < 1 {
        log.Fatal("Cannot pop letter from set. Empty.")
    }
    var letterToReturn = string(game.LetterSet[utf8.RuneCountInString(game.LetterSet)-1])
    game.LetterSet = game.LetterSet[:len(game.LetterSet)-1]
    return letterToReturn
}

func PlaceLetter(game *Game, verticalTileIdx int, horizontalTileIdx int, letter rune) error {
    // add a letter to the board.
    // throw an error if placement of the leter is not legal

    // TODO: Has player who has turn the letter to be placed in hand?

    if isLegal, reason := IsLegalPlacement(verticalTileIdx, horizontalTileIdx, letter, game.Tiles); !isLegal {
        return errors.New("Cannot place letter. " + reason)
    }

    game.Tiles[verticalTileIdx][horizontalTileIdx].Letter = letter
    return nil
}

func RemoveLetter(game *Game, verticalTileIdx int, horizontalTileIdx int, tiles [][]Tile) {
    // Remove one single letter from the board that has
    // not been locked yet

    if game.Tiles[verticalTileIdx][horizontalTileIdx].IsLocked {
        log.Fatal("Cannot remove letter. Tile Locked")
    }

    game.Tiles[verticalTileIdx][horizontalTileIdx].Letter = 0

}

func GetPointsForWord(wordTiles []Tile) (int, error) {
    // calculate the points for a series of
    // tiles, with respect to the point value of a letter
    // and the tile effects

    var word string
    var wordPoints int
    var wordPointMultiplicator int

    for _, tile := range wordTiles {

        tile.IsLocked = true
        word += string(tile.Letter)

        var letterPoints = GetLetterAttributesFromRune(tile.Letter).pointValue
        if tile.Effect == DOUBLE_LETTER_TILE_EFFECT {
            letterPoints *= 2
        } else if tile.Effect == TRIPLE_LETTER_TILE_EFFECT {
            letterPoints *= 3
        } else if tile.Effect == DOUBLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 2
        } else if tile.Effect == TRIPLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 3
        }
        wordPoints += letterPoints

    }

    wordPoints *= wordPointMultiplicator

    if ! golelibs.IsAValidWord(word) {
        errors.New("Not a valid word: " + word)
    }

    return wordPoints, nil

}

func FinishTurn(game *Game) error {

    // Tiles that have already been respected for point calculation
    // Tiles that already were were locked before this current turn
    // may only be taken into account for rating once.
    // Tiles that the player placed in this turn (i.e. currently unlocked)
    // may be counted twice, if they were connected to two different tiles
    var confirmedWordTiles [][]Tile;
    var points int;

    // Get all unlocked tiles
    for verticalIdx, column := range game.Tiles {
        for horizontalIdx, tile := range column {
            if tile.Letter != 0 && ! tile.IsLocked {

                var horizontalWordTiles = GetHorizontalWordAtTile(verticalIdx, horizontalIdx, game.Tiles)
                var verticalWordTiles = GetVerticalWordAtTile(verticalIdx, horizontalIdx, game.Tiles)

                //Check if words have alreaddy been confirmed i.e. rated
                var ignoreHorizontalWord bool
                var ignoreVerticalWord bool
                for _, wordTiles := range confirmedWordTiles {
                    if reflect.DeepEqual(wordTiles, horizontalWordTiles) {
                        ignoreHorizontalWord = true
                    }
                    if reflect.DeepEqual(wordTiles, verticalWordTiles) {
                        ignoreVerticalWord = true
                    }
                }

                if ! ignoreHorizontalWord {
                    horizontalWordPoints, err := GetPointsForWord(horizontalWordTiles)
                    if err != nil {
                        return err
                    }
                    points += horizontalWordPoints
                    confirmedWordTiles = append(confirmedWordTiles, horizontalWordTiles)
                }

                if ! ignoreVerticalWord {
                    verticalWordPoints, err := GetPointsForWord(verticalWordTiles)
                    if err != nil {
                        return err
                    }
                    points += verticalWordPoints
                    confirmedWordTiles = append(confirmedWordTiles, verticalWordTiles)
                }
            }
        }
    }

    // Add earned points to current player
    game.Players[game.PlayerIdxWithTurn].Points += points

    // Give turn to next player
    game.PlayerIdxWithTurn = (game.PlayerIdxWithTurn + 1) % len(game.Players)
    return nil
}
