package main

import (
    "log"
    "os/exec"
    "reflect"
    "strings"
    "errors"
    "./golelibs"
);

type Game struct {
    Id string;
    Players []Player;

    // hold index of player who has the current turn
    PlayerIdxWithTurn int;

    // 2-dimensional array storing all tiles
    // first index represents vertical, second index horizontal tiles
    Tiles [][]Tile;

    // All letters in the backlog
    // i.e. that have not yet been handed to a player
    LetterSet []Letter;
}

var MIN_NUMBER_OF_PLAYERS = 2
var MAX_NUMBER_OF_PLAYERS = 4
var DEFAULT_NUMBER_OF_LETTERS_IN_HAND = 7

func GetNewUUID() string {
    // Generate a new uuid for a new game.
    // Requires:
    // - The existance of a uuidgen binary installed on the machine
    // Guarantees
    // - Return a new uuid as generated by the called binary
    uuid, err := exec.Command("uuidgen").Output()
    if err != nil {
        log.Fatal(err)
    }
    return strings.TrimSpace(string(uuid))
}

func (game *Game) GetPlayerByName(playerName string) (Player, error) {
    // get a player from the given game by their name
    for _, existingPlayer := range game.Players {
        if existingPlayer.Name == strings.TrimSpace(playerName) {
            return existingPlayer, nil
        }
    }
    return Player{}, errors.New("Player with name does not exist in the game. " + playerName)
}

func AddPlayer(playerName string, game *Game) error {
    // Add a player to the list of players for the
    // upcoming game play

    if len(game.Players) >= MAX_NUMBER_OF_PLAYERS {
        return errors.New("No more players can be added to the Game.")
    }

    _, err := game.GetPlayerByName(playerName)
    if err == nil {
        return errors.New("A player with this name already exists.")
    }

    player := Player{Name: playerName}

    for i := 0; i < DEFAULT_NUMBER_OF_LETTERS_IN_HAND; i++ {
        nextLetter, err := PopLetterFromSet(game)
        if err != nil {
            return err
        }
        player.LettersInHand = append(player.LettersInHand, nextLetter)
    }

    game.Players = append(game.Players, player)

    return nil

}

func PopLetterFromSet(game *Game) (Letter, error) {
    // Pop the last letter (right end) from the
    // letter string of the passed game structure instance.
    // The letter will be returned and the
    // occurrence will be removed from the string and stored back to the game.
    if len(game.LetterSet) < 1 {
        return Letter{}, errors.New("Cannot pop letter from set. Empty.")
    }
    var letterToReturn = game.LetterSet[len(game.LetterSet)-1]
    game.LetterSet = game.LetterSet[:len(game.LetterSet)-1]
    return letterToReturn, nil
}

func PlaceLetter(game *Game, verticalTileIdx int, horizontalTileIdx int, letter rune) error {
    // add a letter to the board.
    // throw an error if placement of the leter is not legal

    var err error
    err = game.Players[game.PlayerIdxWithTurn].RemoveLetterFromHand(letter)
    if err != nil {
        return err
    }

    if isLegal, reason := IsLegalPlacement(verticalTileIdx, horizontalTileIdx, letter, game.Tiles); !isLegal {
        return errors.New("Cannot place letter. " + reason)
    }

    var letterStruct Letter
    letterStruct, err = GetLetterStructFromRune(letter)
    if err != nil {
        return err
    }

    game.Tiles[verticalTileIdx][horizontalTileIdx].Letter = letterStruct

    // Update placement legality of whole board
    game.UpdatePlacementLegalityOfAllTiles()

    return nil
}

func RemoveLetter(game *Game, verticalTileIdx int, horizontalTileIdx int) error {
    // Remove one single letter from the board that has
    // not been locked yet

    if game.Tiles[verticalTileIdx][horizontalTileIdx].IsLocked {
        return errors.New("Cannot remove letter. Tile Locked")
    }

    game.Tiles[verticalTileIdx][horizontalTileIdx].Letter = Letter{}

    // Update placement legality of whole board
    game.UpdatePlacementLegalityOfAllTiles()

    return nil

}

func GetPointsForWord(wordTiles []Tile) (int, error) {
    // calculate the points for a series of
    // tiles, with respect to the point value of a letter
    // and the tile effects
    // Return an error if the word is invalid
    // that inclused if the word consists of only one letter

    //if len(wordTiles) < 2 {
    //    return -1, errors.New("Can not get points for word. Too short.")
    //}

    var word string
    var wordPoints int
    wordPointMultiplicator := 1

    for _, tile := range wordTiles {

        tile.IsLocked = true
        word += string(tile.Letter.Character)

        var letterPoints = tile.Letter.Attributes.PointValue
        if tile.Effect == DOUBLE_LETTER_TILE_EFFECT {
            letterPoints *= 2
        } else if tile.Effect == TRIPLE_LETTER_TILE_EFFECT {
            letterPoints *= 3
        } else if tile.Effect == DOUBLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 2
        } else if tile.Effect == TRIPLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 3
        }
        wordPoints += letterPoints

    }

    log.Println("Word to check: " + word)

    wordPoints *= wordPointMultiplicator

    if ! golelibs.IsAValidWord(word) {
        return -1, errors.New("Not a valid word: " + word)
    }

    return wordPoints, nil

}

func FinishTurn(game *Game) error {

    // Tiles that have already been respected for point calculation
    // Tiles that already were were locked before this current turn
    // may only be taken into account for rating once.
    // Tiles that the player placed in this turn (i.e. currently unlocked)
    // may be counted twice, if they were connected to two different tiles
    var confirmedWordTiles [][]Tile;
    var points int;

    // Get all unlocked tiles
    for verticalIdx, column := range game.Tiles {
        for horizontalIdx, tile := range column {
            if tile.Letter != (Letter{}) && ! tile.IsLocked {

                hasHorizontalWord, horizontalWordTiles := GetHorizontalWordAtTile(verticalIdx, horizontalIdx, game.Tiles)
                hasVerticalWord, verticalWordTiles := GetVerticalWordAtTile(verticalIdx, horizontalIdx, game.Tiles)

                log.Println("horizontailTiles: " + TileSliceToString(horizontalWordTiles))
                log.Println("verticalTiles: " + TileSliceToString(verticalWordTiles))

                //Check if words have alreaddy been confirmed i.e. rated
                var ignoreHorizontalWord, ignoreVerticalWord bool
                for _, wordTiles := range confirmedWordTiles {
                    if hasHorizontalWord && reflect.DeepEqual(wordTiles, horizontalWordTiles) {
                        ignoreHorizontalWord = true
                    }
                    if hasVerticalWord && reflect.DeepEqual(wordTiles, verticalWordTiles) {
                        ignoreVerticalWord = true
                    }
                }

                if ! ignoreHorizontalWord && hasHorizontalWord {
                    horizontalWordPoints, err := GetPointsForWord(horizontalWordTiles)
                    if err != nil {
                        return err
                    }
                    points += horizontalWordPoints
                    confirmedWordTiles = append(confirmedWordTiles, horizontalWordTiles)
                }

                if ! ignoreVerticalWord && hasVerticalWord {
                    verticalWordPoints, err := GetPointsForWord(verticalWordTiles)
                    if err != nil {
                        return err
                    }
                    points += verticalWordPoints
                    confirmedWordTiles = append(confirmedWordTiles, verticalWordTiles)
                }
            }
        }
    }

    // Add earned points to current player
    game.Players[game.PlayerIdxWithTurn].Points += points

    // Give turn to next player
    game.PlayerIdxWithTurn = (game.PlayerIdxWithTurn + 1) % len(game.Players)
    log.Printf("Index of player with turn is now: %d", game.PlayerIdxWithTurn)
    return nil
}
