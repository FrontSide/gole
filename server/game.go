package main

import (
    "log"
    "unicode/utf8"
    "os/exec"
    "reflect"
    "./golelibs"
);

type Game struct {
    id string;
    players []Player;

    // 2-dimensional array storing all tiles
    // first index represents vertical, second index horizontal tiles
    tiles [][]Tile;

    // String of all letters in the backlog
    // i.e. that have not yet been handed to a player
    letterSet string;
}

var MIN_NUMBER_OF_PLAYERS = 2
var MAX_NUMBER_OF_PLAYERS = 4
var DEFAULT_NUMBER_OF_LETTERS_IN_HAND = 7

func GetNewUUID() string {
    // Generate a new uuid for a new game.
    // Requires:
    // - The existance of a uuidgen binary installed on the machine
    // Guarantees
    // - Return a new uuid as generated by the called binary
    uuid, err := exec.Command("uuidgen").Output()
    if err != nil {
        log.Fatal(err)
    }
    return string(uuid)
}

func AddPlayer(playerName string, game *Game) {
    // Add a player to the list of players for the
    // upcoming game play

    if len(game.players) >= MAX_NUMBER_OF_PLAYERS {
        log.Fatal("No more players can be added to the Game.")
    }

    player := Player{name: playerName}

    for i := 0; i < DEFAULT_NUMBER_OF_LETTERS_IN_HAND; i++ {
        player.lettersInHand += PopLetterFromSet(game)
    }

    game.players = append(game.players, player)

}

func PopLetterFromSet(game *Game) string {
    // Pop the last letter (right end) from the
    // letter string of the passed game structure instance.
    // The letter will be returned and the
    // occurrence will be removed from the string and stored back to the game.
    if len(game.letterSet) < 1 {
        log.Fatal("Cannot pop letter from set. Empty.")
    }
    var letterToReturn = string(game.letterSet[utf8.RuneCountInString(game.letterSet)-1])
    game.letterSet = game.letterSet[:len(game.letterSet)-1]
    return letterToReturn
}

func GetPointsForWord(wordTiles []Tile) int {

    var word string
    var wordPoints int
    var wordPointMultiplicator int

    for _, tile := range wordTiles {

        tile.locked = true
        word += string(tile.letter)

        var letterPoints = GetLetterAttributesFromRune(tile.letter).pointValue
        if tile.effect == DOUBLE_LETTER_TILE_EFFECT {
            letterPoints *= 2
        } else if tile.effect == TRIPLE_LETTER_TILE_EFFECT {
            letterPoints *= 3
        } else if tile.effect == DOUBLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 2
        } else if tile.effect == TRIPLE_WORD_TILE_EFFECT {
            wordPointMultiplicator += 3
        }
        wordPoints += letterPoints

    }

    wordPoints *= wordPointMultiplicator

    if ! golelibs.IsAValidWord(word) {
        log.Fatalf("Not a valid word: %s", word)
    }

    return wordPoints

}

func FinishTurn(game *Game) {

    // Tiles that have already been respected for point calculation
    // Tiles that already were were locked before this current turn
    // may only be taken into account for rating once.
    // Tiles that the player placed in this turn (i.e. currently unlocked)
    // may be counted twice, if they were connected to two different tiles
    var confirmedWordTiles [][]Tile;
    var points int;

    // Get all unlocked tiles
    for verticalIdx, column := range game.tiles {
        for horizontalIdx, tile := range column {
            if tile.letter != 0 && ! tile.locked {

                var horizontalWordTiles = GetHorizontalWordAtTile(verticalIdx, horizontalIdx, game.tiles)
                var verticalWordTiles = GetVerticalWordAtTile(verticalIdx, horizontalIdx, game.tiles)

                //Check if words have alreaddy been confirmed i.e. rated
                var ignoreHorizontalWord bool
                var ignoreVerticalWord bool
                for _, wordTiles := range confirmedWordTiles {
                    if reflect.DeepEqual(wordTiles, horizontalWordTiles) {
                        ignoreHorizontalWord = true
                    }
                    if reflect.DeepEqual(wordTiles, verticalWordTiles) {
                        ignoreVerticalWord = true
                    }
                }

                if ! ignoreHorizontalWord {
                    points += GetPointsForWord(horizontalWordTiles)
                    confirmedWordTiles = append(confirmedWordTiles, horizontalWordTiles)
                }

                if ! ignoreVerticalWord {
                    points += GetPointsForWord(verticalWordTiles)
                    confirmedWordTiles = append(confirmedWordTiles, verticalWordTiles)
                }
            }
        }
    }
}
